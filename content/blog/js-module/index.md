---
title: 자바스크립트 모듈 시스템 제대로 이해하기
date: '2025-05-05T00:00:00Z'
thumbnail: ./javascript-module.webp
categories: Dev
---

최근 이직을 위해 여러 기술 면접에 참여하면서, 스스로에 대한 부족함을 많이 느끼고 있다.
<br />
다양한 실무 경험들이 쌓이면서 피쳐 개발과 업무를 대하는 방식에 대해서는 방향성을 잡아가고 있지만, 정작 코어 레벨의 개념들에 대해서는 놓쳐오고 있다는 걸 깨달았다. 이미 알고 있는 내용이더라도 남에게 명확하게 설명할 수 있을 정도로 정리되어 있어야 하겠다는 생각이 들어 하나씩 개념을 다잡아 보려고 한다.

그 중, 오늘은 자바스크립트의 모듈 시스템에 대해서 기본 지식부터 실무에서 활용되는 개념들까지 정리해보는 글을 작성해보려고 한다.

<br />
<hr />

## 모듈 시스템이란?

현대 프론트엔드 개발에서 React, Vite, Webpack과 같은 도구들은 모두 "모듈 시스템"을 중심으로 구성된다.
<br />
하지만, 단순히 `import`나 `require`를 사용해본 것 만으로는 모듈 시스템이 무엇이고 어떻게 활용되는지 알기 어렵다.

그렇다면 모듈 시스템은 무엇일까?

<br />

### 모듈 시스템의 필요성

초기의 자바스크립트는 대부분의 스크립트가 독립적인 작업을 수행하며, 간단한 상호 작용을 지원하는 정도의 작업에만 사용되었었지만, 점차 그 범위가 확장되어 현재는 큰 규모의 웹 어플리케이션 개발에도 활용되면서 코드 관리에 여러 가지 문제가 발생하게 되었다.

- 전역 스코프 오염 (Global Scope Pollution): 모든 변수가 전역에 선언되어 충돌 위험이 높음
- 코드 재사용 불가능
- 의존성 추적의 어려움: 어떤 스크립트가 어떤 것에 의존하는지 명시적이지 않음

이러한 문제점을 해결하기 위해 자바스크립트에 도입된 개념이 모듈 시스템이다.
모듈 시스템을 통해 자바스크립트는 코드를 별도의 모듈로 분할하여 모듈 단위의 스코프를 제공하고 코드를 재사용 가능하도록 지원한다.
이렇게 모듈화가 이루어지면 모듈 스코프에 포함된 변수 혹은 함수는 export를 통해 다른 모듈에서도 사용할 수 있게 되고, 다른 모듈에서는 명시적으로 그 변수 혹은 함수에 의존할 수 있게 된다. 이로써 코드들은 각각 독립적으로 작동할 수 있는 단위로 나눠질 수 있게 되고 분리된 코드 조각들을 조합해서 다양한 종류의 어플리케이션을 구현할 수 있게 되는 것이다.

그럼 자바스크립트엔 어떤 모듈 시스템이 사용되는지, 그리고 어떠한 원리로 모듈화가 지원되는지 알아보자.

<br />
<hr />

## CommonJS와 ESM

자바스크립트에서는 주로 CommonJS와 ESM 두 가지 모듈 시스템이 사용된다.

**CommonJS**는 Node.js에서 사용되는 모듈 시스템으로, 주로 서버 환경에서의 모듈화를 위해 사용된다.
<br />
모듈 사용을 위해 `require()`과 `module.exports`를 사용하며, 런타임에 동기적으로 로드되는 특성을 가진다.

**ESM (EcmaScript Modules)** 은 ES6와 함께 도입된 자바스크립트의 표준화된 모듈 시스템으로, `import`와 `export`를 사용하여 모듈을 가져오고 내보낸다.
그리고 CommonJS와 다르게 빌드 타임에 정적으로 로드되어 정적 분석이 가능하다.
이로 인해 여러 브라우저 환경에서도 사용될 수 있고 다양한 이점을 가지게 되는데, 자세한 설명은 뒤에서 자세히 다뤄보도록 하겠다.

그럼 먼저 프론트엔드 개발에서 핵심적인 역할을 하는 ESM의 브라우저 환경에서의 동작 방식을 자세히 살펴보자

### ESM의 동작 방식

브라우저 환경에서 ESM은 entry point인 `<script type="module">`을 만나면 import문을 통해 구성된 모듈 간의 의존성 그래프를 로드하며 동작한다. 이 떄, 브라우저는 해당 파일을 모듈 스크립트로 정의하여 모듈 시스템을 처리하기 위한 일련의 과정을 진행한다.

해당 과정은 크게 다음과 같은 3가지 단계로 나눌 수 있다: **구성 -> 인스턴스화 -> 평가**. 각각의 단계는 모듈 시스템의 핵심 동작 원리를 이해하는 데 중요한 역할을 한다.

#### 1.구성

가장 먼저 수행되는 작업은 모듈 파일을 찾고 가져오는 작업이다. 로더는 모듈의 최상위 entry 파일을 찾아 다운로드한다. 그 이후, import 구문들을 파악하여 모듈 간의 의존성 그래프를 구성하게 된다.

이렇게 구성된 모듈 의존성 그래프의 각 모듈 파일은 어떤 데이터를 내보내고 가져오는 지 모듈 레코드로 구문분석한다. 이렇게 ESM은 정적 구조를 갖기 떄문에 모듈을 실행하지 않고도 의존성 그래프를 완설할 수 있고, 이는 빌드 도구가 **트리 쉐이킹**이나 **코드 스플리팅**을 수행할 수 있는 기반이 된다.

#### 2. 인스턴스화

파싱이 완료되면 각 모듈은 메모리 상에 인스턴스화 된다. 이 단계에서는 각 모듈의 스코프와 변수 환경이 구성되며, export된 식별자들은 메모리 공간을 할당받게 된다. 그러나 이 메모리 공간은 실제 값을 가지진 않으며 평가 단계가 끝난 후 값이 채워지게 된다. 다만 이 단계에선 모듈 간의 의존성 대응을 위해 임시 객체를 통해 모듈 간의 연결을 설정한다.

#### 3. 평가

마지막으로, 모듈의 최상위 코드가 실행되어 할당된 메모리에 실제 데이터를 채워 넣는다. 이 떄, 브라우저는 의존성 그래프를 따라 모듈을 순차적으로 실행하며, 각 모듈은 평가 도중의 서버 요청과 같은 의도하지 않은 부작용을 방지하기 위해 **한 번만 실행된어 모듈의 실행 결과가 싱글톤처럼 유지**된다.

<br />
<hr />

## 모듈 시스템의 한계와 번들러의 필요성

이렇게 모듈 시스템과 그 중 ESM의 동작 과정에 대해 살펴보았는데, 실제 브라우저와 프론트엔드 개발 환경에서는 모듈 시스템 만으로는 다음과 같은 해결하기 어려운 실용적인 한계점들이 존재한다.

- HTTP 요청 증가
  - ESM은 각 import문 마다 별도의 HTTP 요청 수행
  - 모듈 개수가 많아질 수록 브라우저 요청 수 증가로 인한 요청 병목 및 로딩 성능 저하
- 최적화 부족
  - ESM은 코드 구조를 정적 분석할 수 있지만, 브라우저는 실제로 사용하지 않는 코드도 모두 로드
  - 사용되지 않는 코드까지 로딩되어 초기 렌더 속도와 사용자 경험에 악영향을 줄 수 있음
- 호환성 문제
  - 브라우저는 CommonJS(require)를 전혀 이해하지 못함
  - 외부 라이브러리가 CommonJS로 되어 있을 경우 직접 사용 불가, 별도 트랜스파일링 필요

이러한 문제들을 해결하기 위해 등장한 것이 바로 **번들러(Bundler)** 다. 대표적인 번들러로는 Vite, Webpack, Rollup 등이 있으며, 이들은 다음과 같은 방식으로 모듈 시스템의 한계를 보완한다.

우선 번들러는 `import`를 정적으로 분석해 전체 의존성 그래프를 구성한 뒤, 수많은 파일을 하나의 번들 파일로 묶어 HTTP 요청을 최소화한다. 또한, ESM의 정적 구조를 바탕으로 사용되지 않는 export를 제거하는 **트리 쉐이킹(tree shaking)** 과 import() 구문을 기준으로 코드를 여러 개의 청크(chunk)로 나눠 필요한 시점에 필요한 코드만 로딩하는 **코드 스플리팅(code splitting)** 등 다양한 최적화 기법을 적용할 수 있다. 이러한 최적화 방법들은 모두 브라우저가 제공하지 못하는 기능을 번들러가 빌드 시점에 정적인 모듈 구조를 바탕으로 수행해줌으로써 초기 로딩 속도를 개선하고, 사용자와의 상호작용이 일어날 때 필요한 모듈만 로딩하는 구조로 성능을 끌어올릴 수 있다.

뿐만 아니라, 번들러는 CommonJS와 ESM 사이의 문법 호환성을 자동으로 처리하며, TypeScript, JSX, Sass 등의 파일도 브라우저가 이해할 수 있는 순수 JavaScript나 CSS로 트랜스파일링 해준다. 이 모든 과정을 거친 결과물은 크기가 작고, 구조가 최적화된 형태로 브라우저에 전달된다.

결국 번들러는 모듈 시스템의 구조적 한계와 브라우저 환경의 제약을 극복하기 위한 실용적 해답이라고 할 수 있다. 현대적인 프론트엔드 개발에서 번들러는 단순히 코드를 합치는 도구가 아니라, 개발 효율성과 실행 성능을 모두 잡기 위한 핵심 인프라로 자리 잡고 있다.

<br />
<hr />

## 마치며

자바스크립트 모듈 시스템은 단순히 코드를 나누는 기능을 넘어서, 현대 웹 개발에서 성능 최적화를 위한 필수 요소라고 볼 수 있다. 모듈 시스템을 통해 코드의 재사용성과 유지 보수성을 높이고, 웹 어플리케이션의 성능까지 최적화할 수 있다.

결국 프론트엔드 개발자는 자바스크립트 모듈 시스템의 구조와 한계를 이해하고 그 위에서 동작하는 번들러의 작동 원리까지 함께 숙지해야 확장 가능하고 성능 좋은 웹 애플리케이션을 만들 수 있다. 모듈 시스템은 단순한 기술 사양이 아니라 웹 아키텍처의 중심이 될 수 있는 개념이며, 이를 잘 이해하는 것이 더 깊이 있는 프론트엔드 개발자가 될 수 있는 중요한 기준 중 하나가 될 수 있다고 생각한다.

이 글을 작성하면서 모듈 시스템에 대한 전반적인 개념을 이해해 보았으며, 이를 바탕으로 더욱 탄탄한 프론트엔드 개발을 이어가보도록 하겠다. 💪

<br />
<hr />

## Ref

- https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive
- https://medium.com/@Dodo3/javascript-modules-unlocked-a-deep-dive-into-esm-vs-commonjs-84abf3075c41
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Modules

<br />
